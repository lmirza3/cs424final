<html>
	<head>
		<title>A Leaflet map!</title>
		<script src="http://d3js.org/d3.v4.min.js" type="text/javascript"></script>
			<link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-0.7.3/leaflet.css"/>
		<script src="http://cdn.leafletjs.com/leaflet-0.7.3/leaflet.js"></script>
		<style>
			#map{ width: 900px; height: 500px; }

			svg {
			position: relative;
			}

			path {
			fill: yellow;
			stroke-width: 2px;
			stroke: red;
			stroke-opacity: 1;
			}

			.waypoints {
			fill: red;
			opacity: 1;
			}

			.lineConnect {
			fill: none;
			stroke: black;
			opacity: 1;
			}

			.travelMarker {
			fill: yellow;
			opacity: 0.75;
			}

		</style>
	</head>
	<body>

		<div id="map"></div>

		<script>

			// initialize the map
			var map = L.map('map').setView([41.8711095, -87.64749043], 18);

			// load a tile layer
			L.tileLayer('https://api.mapbox.com/styles/v1/mapbox/dark-v9/tiles/256/{z}/{x}/{y}?access_token=pk.eyJ1IjoiZW1lbG8yIiwiYSI6ImNpdzRsejFncjAwNWEyenA1NGJ0YXE3N2UifQ.FySGNTbHiTK-_9_SAMgVcA',
			{
			attribution: 'Tiles by <a href="http://mapc.org">MAPC</a>, Data by <a href="http://mass.gov/mgis">MassGIS</a>',
			maxZoom: 50,
			minZoom: 13
			}).addTo(map);

			var svg = d3.select(map.getPanes().overlayPane).append("svg");
			var g = svg.append("g").attr("class", "leaflet-zoom-hide");


			d3.csv("cs424data-avg.csv", function(dataAvg) {
				d3.csv("cs424data.csv", function(dataSet) {

					//debug check dsv parse
					//console.log(dataSet);
					//console.log(dataAvg);

					//canvas
					var width = 650,
						height = 600,
						cw = width/2,
						ch = height/2;

					//frequency sets
					var freq700 = [],
						freq850 = [],
						freq1700 = [],
						freq1900 = [];

					dataSet.forEach(function(d){
						freq700.push(parseFloat(d.f700));
						freq850.push(parseFloat(d.f850));
						freq1700.push(parseFloat(d.f1700));
						freq1900.push(parseFloat(d.f1900));
					});
					//popping the end element, because object column gets parsed in
					freq700.pop();
					freq850.pop();
					freq1700.pop();
					freq1900.pop();

					//debug check freq array
					//console.log(freq700);
					//console.log(freq850);

					//edge decibels
					var tmpArr = freq700.concat(freq850, freq1700, freq1900);
					var maxDB = Math.max.apply(Math, tmpArr),
						minDB = Math.min.apply(Math, tmpArr);

					//debug check tmp and min/max
					//console.log(tmpArr);
					//console.log(maxDB);
					//console.log(minDB);

					var pi = Math.PI;


					d3.json("location.geojson", function(collection) {

						var transform = d3.geoTransform({
							point: projectPoint
						});

						var d3path = d3.geoPath().projection(transform);

						var ptFeatures = g.selectAll("circle")
							.data(collection.features)
							.enter()
							.append("circle")
							.attr("r", 5)
							.style("fill", "red")
							.style("opacity", "1")
							//.attr("class", "waypoints");
							.on("mouseover", handleMouseOver)
							.on("mouseout", handleMouseOut);

						var marker = g.append("circle")
							.attr("r", 10)
							.attr("id", "marker")
							.attr("class", "travelMarker");

						map.on("viewreset", reset);

						reset();
						//transition();

						function projectPoint(x, y) {
							var point = map.latLngToLayerPoint(new L.LatLng(y, x));
							this.stream.point(point.x, point.y);
						}


						function applyLatLngToLayer(d) {
							var y = d.geometry.coordinates[1]
							var x = d.geometry.coordinates[0]
							return map.latLngToLayerPoint(new L.LatLng(y, x))
						}

						function reset() {
							var bounds = d3path.bounds(collection),
							topLeft = bounds[0],
							bottomRight = bounds[1];
							// here you're setting some styles, width, heigh etc
							// to the SVG. Note that we're adding a little height and
							// width because otherwise the bounding box would perfectly
							// cover our features BUT... since you might be using a big
							// circle to represent a 1 dimensional point, the circle
							// might get cut off.


							ptFeatures.attr("transform",
							function(d) {
								return "translate(" +
								applyLatLngToLayer(d).x + "," +
								applyLatLngToLayer(d).y + ")";
							});
							// again, not best practice, but I'm harding coding
							// the starting point

							// Setting the size and location of the overall SVG container
							svg.attr("width", bottomRight[0] - topLeft[0] + 120)
								.attr("height", bottomRight[1] - topLeft[1] + 120)
								.style("left", topLeft[0] - 50 + "px")
								.style("top", topLeft[1] - 50 + "px");
							//linePath.attr("d", d3path);
							//linePath.attr("d", toLine)
							// ptPath.attr("d", d3path);
							g.attr("transform", "translate(" + (-topLeft[0] + 50) + "," + (-topLeft[1] + 50) + ")");
						
						} // end reset

						function handleMouseOver(d){
							var transform = d3.select(this).attr("transform");
							var comma = transform.indexOf(",");
							var openP = transform.indexOf("(");
							var closeP = transform.indexOf(")");

							var x = Number(transform.slice(openP + 1, comma));
							var y = Number(transform.slice(comma + 1, closeP));

							// console.log(d.geometry.coordinates[1]);

							sunburst(x, y, d.geometry.coordinates[1], d.geometry.coordinates[0]);
						}

						function handleMouseOut(){
							d3.selectAll(".spin1").remove();

						}

						function sunburst(x, y, lat, long){

						// console.log(x);
						// console.log(y);
						// console.log(lat);

						var i = 0;
						var avgInfo;
						while(i < dataAvg.length){
							//console.log(dataAvg[i]);
							if(dataAvg[i].latitude == lat && dataAvg[i].longitude == long){
								avgInfo = dataAvg[i];
								break;
							}
							i++;
						}
						// console.log(avgInfo);

						//sunburst scale
            var sunArcScale = d3.scaleLinear()
            	.domain([minDB, maxDB])
            	.range([30, 80])

						//set svg canvas
        		// var canvas = d3.select("body").append("svg")
            // 	.attr("width", width)
            // 	.attr("height", height)

            // var group = canvas.append("g")
      				// .attr("transform", "translate("+ x +","+ y +")");


            // console.log(avgInfo.f700avg);
            var tmpVal = {};
            tmpVal[0] = {val: avgInfo.f700avg, color: "blue", speed: 5};
            tmpVal[1] = {val: avgInfo.f850avg, color: "red", speed: 5};
            tmpVal[2] = {val: avgInfo.f1700avg, color: "green", speed: 5};
            tmpVal[3] = {val: avgInfo.f1900avg, color: "yellow", speed: 5};
            // tmpVal[4] = {val: setInfo.f700, color: "blue", speed: 3};
            // tmpVal[5] = {val: setInfo.f850, color: "red", speed: 3};
            // tmpVal[6] = {val: setInfo.f1700, color: "green", speed: 3};
            // tmpVal[7] = {val: setInfo.f1900, color: "yellow", speed: 3};
         
      			for (i=0; i < 4; i++){

	            var arc = d3.arc()
        				.innerRadius(30)
        				.outerRadius((sunArcScale(tmpVal[i].val)))
        				.startAngle(i * 90 * (pi/180))
        				.endAngle((i+1) * 90 * (pi/180))
        				.padAngle(5*(pi/180))

							var drawArc = g.append("path")
								.style("fill", tmpVal[i].color)
								.style("opacity", .6)
								.style("stroke", "none")
								.attr("d", arc)
								.attr("class", "spin1")
								.attr("transform", "translate("+ x +","+ y +")");
							

							
						}

      			var t0 = Date.now();

						d3.timer(function(){
							var delta = (Date.now() - t0);
							g.selectAll(".spin1")
								.attr("transform", function(d){
									return "translate("+ x +","+ y +") rotate(" + 100 + delta * 7/200 + ")";
								});
							// group.selectAll(".spin2")
							// 	.attr("transform", function(d){
							// 		return "rotate(" + 100 + delta * 4/200 + ")";
							// 	});
						});
					}

					});
				});
			});




		</script>
	</body>
</html>